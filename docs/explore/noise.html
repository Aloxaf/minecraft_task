<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>深入探索 - 噪声函数</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/img/favicon.png" type="image/x-icon" />
<link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css"></script>
<script src="https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="/js/common.js"></script>
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/article.css">
</head>

<body>
    <!-- 导航栏 -->
<nav class="navbar navbar-default" role="navigation">
    <div class="container-fluid">
        <!-- 图标 -->
        <div class="navbar-header">
            <a href="/index.html">
                <img src="/img/logo.png" class="logo" alt="首页">
            </a>
        </div>
        <!-- 导航目录 -->
        <div>
            <ul class="nav navbar-nav">
                <li id="index"><a href="/index.html">首页</a></li>
                <li id="introduce"><a href="/introduce.html">游戏简介</a></li>
                <li id="explore" class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                        深入探索
                        <b class="caret"></b>
                    </a>
                    <ul class="dropdown-menu">
                        <li><a href="/explore/world.html">世界生成</a></li>
						<li><a href="/explore/ecosystem.html">生物群系</a></li>
						<li><a href="/explore/noise.html">噪声函数</a></li>
						<li><a href="/explore/terrain.html">基本地形</a></li>
						<li><a href="/explore/cave.html">洞穴</a></li>
						<li><a href="/explore/explode.html">爆炸算法</a></li>
                    </ul>
                </li>
                <li id="strategy"><a href="/strategy.html">游戏攻略</a></li>
                <li id="about" class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                        关于我们
                        <b class="caret"></b>
                    </a>
                    <ul class="dropdown-menu">
                        <li><a href="/about/video.html">小组视频</a></li>
                        <li><a href="/about/about.html">我们的话</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <script>
        $('#explore').addClass('active')
    </script>
</nav>

    <div class="content_wrapper">
        <div class="sidebar">
            <ol>
<li><a href="#%3Cstrong%3E%E5%90%84%E7%A7%8Dnoisegenerator%3C%2Fstrong%3E"><strong>各种NoiseGenerator</strong></a></li><ol>
<li><a href="#noisegeneratorimproved">NoiseGeneratorImproved</a></li>
</ol>
</ol>
        </div>
        <div class="content_border">
            <div class="content_border_top"></div>
            <div class="content_border_left">
                <div class="content_border_right">
                    <div class="content">
                        <p>接下来的地形生成代码会接触到噪声函数，所以本篇内容就先逆向MC的噪声函数吧</p>
<p>噪声函数就是比较好看的随机数，如果用纯随机数（白噪声）不适合生成地形，但是噪声函数就很适合</p>
<h1 id="%3Cstrong%3E%E5%90%84%E7%A7%8Dnoisegenerator%3C%2Fstrong%3E"><a href="#%3Cstrong%3E%E5%90%84%E7%A7%8Dnoisegenerator%3C%2Fstrong%3E" class="anchor"></a><strong>各种NoiseGenerator</strong></h1><p>在包net.minecraft.world.gen里可以看到几个噪声生成器，它们的命名比较乱所以不要看类名来推断算法（本来柏林噪声的命名就经常被混淆），其实MC里只有Perlin噪声和Simplex噪声</p>
<h2 id="noisegeneratorimproved"><a href="#noisegeneratorimproved" class="anchor"></a>NoiseGeneratorImproved</h2><p>用来生成一个柏林噪声</p>
<pre><code class="language-java">public class NoiseGeneratorImproved extends NoiseGenerator
{
    // 0~255的随机排列
    private int[] permutations;
    // 坐标偏移量
    public double xCoord;
    public double yCoord;
    public double zCoord;
    // 三维梯度向量，去掉y维度后和二维的一样
    private static final double[] field_152381_e = new double[] {1.0D, -1.0D,  1.0D, -1.0D, 1.0D, -1.0D,  1.0D, -1.0D, 0.0D,  0.0D,  0.0D,  0.0D, 1.0D,  0.0D, -1.0D,  0.0D};
    private static final double[] field_152382_f = new double[] {1.0D,  1.0D, -1.0D, -1.0D, 0.0D,  0.0D,  0.0D,  0.0D, 1.0D, -1.0D,  1.0D, -1.0D, 1.0D, -1.0D,  1.0D, -1.0D};
    private static final double[] field_152383_g = new double[] {0.0D,  0.0D,  0.0D,  0.0D, 1.0D,  1.0D, -1.0D, -1.0D, 1.0D,  1.0D, -1.0D, -1.0D, 0.0D,  1.0D,  0.0D, -1.0D};
    // 二维梯度向量
    private static final double[] field_152384_h = new double[] {1.0D, -1.0D,  1.0D, -1.0D, 1.0D, -1.0D,  1.0D, -1.0D, 0.0D,  0.0D,  0.0D,  0.0D, 1.0D,  0.0D, -1.0D,  0.0D};
    private static final double[] field_152385_i = new double[] {0.0D,  0.0D,  0.0D,  0.0D, 1.0D,  1.0D, -1.0D, -1.0D, 1.0D,  1.0D, -1.0D, -1.0D, 0.0D,  1.0D,  0.0D, -1.0D};

    public NoiseGeneratorImproved()
    {
        this(new Random());
    }

    public NoiseGeneratorImproved(Random rand)
    {
        this.permutations = new int[512];
        this.xCoord = rand.nextDouble() * 256.0D;
        this.yCoord = rand.nextDouble() * 256.0D;
        this.zCoord = rand.nextDouble() * 256.0D;

        // 生成0~255的随机排列

        for (int i = 0; i &lt; 256; ++i)
        {
            this.permutations[i] = i;
        }

        for (int i = 0; i &lt; 256; ++i)
        {
            // 从i~255中选j
            int j = rand.nextInt(256 - i) + i;
            // 把i和j交换
            int t = this.permutations[i];
            this.permutations[i] = this.permutations[j];
            this.permutations[j] = t;
            // 形成一个周期
            this.permutations[i + 256] = this.permutations[i];
        }
    }

    // 在a与b间线性插值
    public final double lerp(double t, double a, double b)
    {
        return a + t * (b - a);
    }

    // 返回与二维梯度向量点乘的结果，参数：梯度向量索引, 向量（其实就是权重）
    public final double func_76309_a(int index, double xWeight, double zWeight)
    {
        int i = index % 16;
        return   field_152384_h[i] * xWeight
               + field_152385_i[i] * zWeight;
    }

    /**
     * pars: noiseArray , xOffset , yOffset , zOffset , xSize , ySize , zSize , xScale, yScale , zScale , noiseScale.
     * noiseArray should be xSize*ySize*zSize in size
     */
    // 这个noiseScale和振幅成反比...
    public void populateNoiseArray(double[] result, double xOffset, double yOffset, double zOffset, int xSize, int ySize, int zSize, double xScale, double yScale, double zScale, double noiseScale)
    {
        if (ySize == 1) // 二维
        {
            int resultIndex = 0;
            // 结果缩放系数，和noiseScale成反比
            double noiseRatio = 1.0D / noiseScale;

            for (int _x = 0; _x &lt; xSize; ++_x)
            {
                // 经过偏移和缩放的x
                double x = xOffset + (double)_x * xScale + this.xCoord;
                // 不大于x的最大整数
                int xFloor = (int)x;
                if (x &lt; (double)xFloor)
                {
                    --xFloor;
                }

                int xIndex = xFloor % 256;
                // 此时x为晶格内的坐标[0, 1)
                x = x - (double)xFloor;
                // 缓和曲线s(t) = 6t^5 - 15t^4 + 10t^3
                double sx = x * x * x * (x * (x * 6.0D - 15.0D) + 10.0D);

                for (int _z = 0; _z &lt; zSize; ++_z)
                {
                    // 经过偏移和缩放的z
                    double z = zOffset + (double)_z * zScale + this.zCoord;
                    // 不大于z的最大整数
                    int zFloor = (int)z;
                    if (z &lt; (double)zFloor)
                    {
                        --zFloor;
                    }

                    int zIndex = zFloor % 256;
                    // 此时z为晶格内的坐标[0, 1)
                    z = z - (double)zFloor;
                    // 缓和曲线s(t) = 6t^5 - 15t^4 + 10t^3
                    double sz = z * z * z * (z * (z * 6.0D - 15.0D) + 10.0D);

                    // 取梯度向量G=G[(i+P[j])mod n]
                    // 左上角梯度向量索引
                    int vecIndex1 = this.permutations[this.permutations[xIndex]] + zIndex;
                    // 右上角梯度向量索引
                    int vecIndex2 = this.permutations[this.permutations[xIndex + 1]] + zIndex;

                    // x方向上点乘（加权），结果用缓和曲线插值
                    double xRes1 = this.lerp(sx,
                                             this.func_76309_a(this.permutations[vecIndex1],          x ,       z),
                                             this.grad(        this.permutations[vecIndex2], -(1.0D - x), 0.0D, z));
                    double xRes2 = this.lerp(sx,
                                             this.grad(this.permutations[vecIndex1 + 1],          x , 0.0D, -(1.0D - z)),
                                             this.grad(this.permutations[vecIndex2 + 1], -(1.0D - x), 0.0D, -(1.0D - z)));
                    // 两个x方向的结果在z方向用缓和曲线插值
                    double res = this.lerp(sz, xRes1, xRes2);

                    result[resultIndex++] += res * noiseRatio;
                }
            }
        }
        else // 三维，参考上面，懒得写注释和反混淆了...
        {
            int resultIndex = 0;
            double noiseRatio = 1.0D / noiseScale;
            int lastYIndex = -1;

            for (int _x = 0; _x &lt; xSize; ++_x)
            {
                double x = xOffset + (double)_x * xScale + this.xCoord;
                int xFloor = (int)x;

                if (x &lt; (double)xFloor)
                {
                    --xFloor;
                }

                int xIndex = xFloor % 256;
                x = x - (double)xFloor;
                double sx = x * x * x * (x * (x * 6.0D - 15.0D) + 10.0D);

                for (int _z = 0; _z &lt; zSize; ++_z)
                {
                    double z = zOffset + (double)_z * zScale + this.zCoord;
                    int zFloor = (int)z;

                    if (z &lt; (double)zFloor)
                    {
                        --zFloor;
                    }

                    int zIndex = zFloor % 256;
                    z = z - (double)zFloor;
                    double sz = z * z * z * (z * (z * 6.0D - 15.0D) + 10.0D);

                    double xRes1, xRes2, xRes3, xRes4;

                    for (int _y = 0; _y &lt; ySize; ++_y)
                    {
                        double y = yOffset + (double)_y * yScale + this.yCoord;
                        int yFloor = (int)y;

                        if (y &lt; (double)yFloor)
                        {
                            --yFloor;
                        }

                        int yIndex = yFloor % 256;
                        y = y - (double)yFloor;
                        double sy = y * y * y * (y * (y * 6.0D - 15.0D) + 10.0D);

                        if (_y == 0 || yIndex != lastYIndex)
                        {
                            lastYIndex = yIndex;
                            int l = this.permutations[xIndex] + yIndex;
                            int i1 = this.permutations[l] + zIndex;
                            int j1 = this.permutations[l + 1] + zIndex;
                            int k1 = this.permutations[xIndex + 1] + yIndex;
                            int l1 = this.permutations[k1] + zIndex;
                            int i2 = this.permutations[k1 + 1] + zIndex;
                            xRes1 = this.lerp(sx, this.grad(this.permutations[i1], x, y, z), this.grad(this.permutations[l1], x - 1.0D, y, z));
                            xRes2 = this.lerp(sx, this.grad(this.permutations[j1], x, y - 1.0D, z), this.grad(this.permutations[i2], x - 1.0D, y - 1.0D, z));
                            xRes3 = this.lerp(sx, this.grad(this.permutations[i1 + 1], x, y, z - 1.0D), this.grad(this.permutations[l1 + 1], x - 1.0D, y, z - 1.0D));
                            xRes4 = this.lerp(sx, this.grad(this.permutations[j1 + 1], x, y - 1.0D, z - 1.0D), this.grad(this.permutations[i2 + 1], x - 1.0D, y - 1.0D, z - 1.0D));
                        }

                        double yRes1 = this.lerp(sy, xRes1, xRes2);
                        double yRes2 = this.lerp(sy, xRes3, xRes4);
                        double res = this.lerp(sz, yRes1, yRes2);

                        result[resultIndex++] += res * noiseRatio;
                    }
                }
            }
        }
    }
}</code></pre>
<p># </p>

                        <p>以上内容来自：<a href="https://blog.csdn.net/xfgryujk/article/details/64133242">CSDN博客</a></p>
                    </div>
                </div>
            </div>
            <div class="content_border_foot"></div>
        </div>
    </div>
</body>

</html>